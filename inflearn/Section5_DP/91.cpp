#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

int res[100];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;

    cin >> n;
    res[1] = 1;
    res[2] = 2;
    for (int i = 3; i <= n; i++){
        res[i] = res[i-1] + res[i-2];
    }
    cout << res[n];
}


// 동적계획법이란?
// 물어보는 문제의 수준은 그대로 유지하면서, 문제의 크기를 우리가 직관적으로 파악할 수 있는 정도로 
// 아주 작은 정도로 문제의 크기로 나누는 것.
// 그 다음 그 작아진 문제의 답을 구해내는 것이다.
// 물어본 내용은 같게하고 크기만 작게하는 것. 
// 즉, 충분히 작게 만든다음 직관적으로 답을 구해버리는 것.

// 그 작은 것에 대한 해답을 구해서 어디다가 기록해둔다. (메모이제이션)
// 그 다음에 이 문제보다 조금 더 큰 크기로 문제를 확장한다. 이 문제의 해를 구함에 있어 앞에서 구해놨던
// 조금 더 작은 문제의 해들을 응용.
// 그 다음에 또 이 문제보다 조금 더 큰 크기로 문제를 확장. 또 앞에서 구해놨던 해들을 응용해서 푼다

// 예르 들어서 가장 작은 문제의 해가 1이었다. 그 보다 조금 더 큰 크기의 해를 구하는데 그게 2였다. 
// 앞의 것에서 2를 곱한 것이다. 다시 조금 더 큰 크기의 해를 구하는데 그게 4였다. 이또한 바로 앞에 2를 곱한 것이었다.
// 이는 수학에서 배우는 점화식이 된다. (지금은 사라졌음)

// 점화식이란? 
// f(n) = 2 * f(n-1)
// An+1 = 2 * An

// 위에서 다룬 점화식 예시의 경우엔 바로 앞의 해만 사용했지만, 다른 문제의 경우엔 앞에서 구해놓은 모든 해들을 사용할 수도 있다.

// 이렇게 문제를 조금씩 확장해나가며 앞의 문제의 해를 활용해서 최종적으로 구하고자 했던 문제의 해를 구하는 것.

// 아주 작은 문제에서 시작해서 크기를 점차 키워서 최종적 문제의 해를 구해내는 것을 바텀업적 다이나믹 프로그래밍이라 한다.

// 바텀업적 DP에서는 내가 딱 보고 직관적으로 알 수 있는 것은 미리 초기화를 해두고 시작한다. 피보나치 수열에서 1, 2항 값이 대표적.
// 그 다음에 시작하면 됨.
// 그 다음에는 점화식을 사용해서 각 해 사이의 관계를 알아내야 한다. 
// HOW? 직접 작은 해부터 구해봐야 함. 그래서 규칙성을 발견!

// 탑다운은 미리 구해놓은 값들을 기록해두고 재귀 시에 불필요한 연산을 방지하는 메모이제이션을 활용하는 것.
